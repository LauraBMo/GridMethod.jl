var documenterSearchIndex = {"docs":
[{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"norms_const/#Norms-and-constants","page":"Norms and constants","title":"Norms and constants","text":"","category":"section"},{"location":"tree/","page":"Tree fractal","title":"Tree fractal","text":"using Plots; gr()\nPlots.reset_defaults()","category":"page"},{"location":"tree/#Cross-Tree-fractal-in-cube","page":"Tree fractal","title":"Cross-Tree fractal in cube","text":"","category":"section"},{"location":"tree/","page":"Tree fractal","title":"Tree fractal","text":"The nodes of the grid form the leaves of a cross-form tree fractal.   The tree function generates the Nth level leaves of a tree fractal with dim dimensions.    It generates new points for the fractal iteratively.","category":"page"},{"location":"tree/#Tree-fractal","page":"Tree fractal","title":"Tree fractal","text":"","category":"section"},{"location":"tree/","page":"Tree fractal","title":"Tree fractal","text":"(Image: Tree fractal in 2D)","category":"page"},{"location":"tree/","page":"Tree fractal","title":"Tree fractal","text":"See Image code","category":"page"},{"location":"tree/#Documentation","page":"Tree fractal","title":"Documentation","text":"","category":"section"},{"location":"tree/","page":"Tree fractal","title":"Tree fractal","text":"Modules = [GridMethod]\nPages   = [\"Tree.jl\"]\nPrivate = false","category":"page"},{"location":"tree/#GridMethod.Tree","page":"Tree fractal","title":"GridMethod.Tree","text":"Tree{T,d}\n\nStructure representing a tree fractal in d-dim space with points of type T.\n\n\n\n\n\n","category":"type"},{"location":"tree/#GridMethod.pmones-Union{Tuple{}, Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T","page":"Tree fractal","title":"GridMethod.pmones","text":"pmones(d::Int = 2, ::Type{T} = Float64)\n\nReturns an iterator which generates all possible d-dimensional vectors that have all components either one or -one.\n\n\n\n\n\n","category":"method"},{"location":"tree/#GridMethod.tree-Union{Tuple{d}, Tuple{T}, Tuple{Tree{T, d}, Any}} where {T, d}","page":"Tree fractal","title":"GridMethod.tree","text":"tree(root::Tree{T, d}, N; ratio = 0.5, dirs = pmones(T, dim))\n\nReturns the Nth leaves of a 2^d-branched tree in a d-dimensional space with root root, where N is the number of times the root-tree should be recursively branched into directions dirs.\n\nKeyword arguments:\n\nratio: The ratio between the length of the recursively branched.\ndirs: The possible directions in which the next leaves can be generated.\n\n\n\n\n\n","category":"method"},{"location":"tree/#GridMethod.tree_findnextleaves-Union{Tuple{d}, Tuple{T}, Tuple{Any, Tree{T, d}}} where {T, d}","page":"Tree fractal","title":"GridMethod.tree_findnextleaves","text":"tree_findnextleaves(i, tree::Tree{T, d}) where {T, d}\n\nReturns the 2^d-1 nodes of tree which branched from the i-th node of the previous tree in the recursive construction.\n\n\n\n\n\n","category":"method"},{"location":"tree/#GridMethod.tree_nexttree-Union{Tuple{d}, Tuple{T}, Tuple{Tree{T, d}, Any}, Tuple{Tree{T, d}, Any, Any}} where {T, d}","page":"Tree fractal","title":"GridMethod.tree_nexttree","text":"tree_nexttree(tree, ratio, dim, dirs = pmones(T, d))\n\nReturns the next iteration of tree with a ratio of length ratio. Where dim is the dimension of the tree, and dirs the directions generating next leaves.\n\n\n\n\n\n","category":"method"},{"location":"tree/#Image-code","page":"Tree fractal","title":"Image code","text":"","category":"section"},{"location":"tree/","page":"Tree fractal","title":"Tree fractal","text":"Code used to generate image Tree fractal.","category":"page"},{"location":"tree/","page":"Tree fractal","title":"Tree fractal","text":"using Plots\nusing GridMethod\n\nfunction plot_lines!(P, N, r, w, dw, c, dc)\n    r₀, w₀, c₀ = r, w, c\n    tree = Tree()\n    dirs = pmones()\n    @gif for _ in 0:(N-1)\n        new_tree = tree_nexttree(tree, r₀, dirs)\n        for (i, p) in tree\n            for q in tree_findnextleaves(i, new_tree)\n                pp = [p, q, [NaN, NaN]]\n                plot!(P, first.(pp), last.(pp), line = (:black, w₀, c₀))\n            end\n        end\n        r₀ *= r\n        w₀ += dw\n        c₀ += dc\n        tree = new_tree\n    end every 1\nend\n\nP = plot(1,\n         legend = false,\n         color = :black,\n         xlim = (-1, 1),\n         ylim = (-1, 1),\n         );\nplot_lines!(P, 7, .5, 2.3, -.4, .75, -.11)","category":"page"},{"location":"grid_refine/#The-grid-and-refining-it","page":"Grid and refine","title":"The grid and refining it","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = GridMethod","category":"page"},{"location":"#GridMethod","page":"Introduction","title":"GridMethod","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation for GridMethod.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a project aiming at implementing the Grid Method theoretically developed by Bürgisser, Cucker, Krick, Lairez, Shub and Tonelli-Cueto.  The aim of this project is to develop parallelizable algorithms for solving real polynomial systems and computing the topology of real algebraic and semialgebraic sets...","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Problem formulation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"modelingkits.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The grid","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"grid_refine.md\",\n    \"cubeHan.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Cross-tree fractal","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"tree.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Norms and constants","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"norms_const.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Utils","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"utils.md\",\n]\nDepth = 2","category":"page"},{"location":"modelingkits/#Modeling-kits","page":"Modeling Kits","title":"Modeling kits","text":"","category":"section"},{"location":"modelingkits/","page":"Modeling Kits","title":"Modeling Kits","text":"We do not implement a modeling language. Instead, we offer easily to build compatibility with your favorite system. Available packages are HomotopyContinuation.ModelKit.jl and ModelingToolkit.jl. See their configuration files HC.ModelKit.jl and ModelingToolkit.jl.","category":"page"},{"location":"modelingkits/","page":"Modeling Kits","title":"Modeling Kits","text":"Modules = [GridMethod]\nPages   = [\"HC.ModelKit.jl\", \"ModelingToolkit.jl\"]","category":"page"},{"location":"cubeHan/#Dividing-the-cube-under-Han-condition","page":"Cube – Han","title":"Dividing the cube under Han condition","text":"","category":"section"}]
}
