var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GridMethod","category":"page"},{"location":"#GridMethod","page":"Home","title":"GridMethod","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GridMethod.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a project aiming at implementing the Grid Method theoretically developed by Bürgisser, Cucker, Krick, Lairez, Shub and Tonelli-Cueto.  The aim of this project is to develop parallelizable algorithms for solving real polynomial systems and computing the topology of real algebraic and semialgebraic sets...","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GridMethod]","category":"page"},{"location":"#GridMethod.grid_point","page":"Home","title":"GridMethod.grid_point","text":"grid_point{T}\n\nStructure representing a node in the grid.\n\nFields\n\nx: Vector of coordinates of the point.\nfx: Value of the function at x.\nstep: Step of the subdivided point.\n\n\n\n\n\n","category":"type"},{"location":"#GridMethod.grid_point-Tuple{Any, Any, Any}","page":"Home","title":"GridMethod.grid_point","text":"grid_point(x, fx, step)\n\nCreates a new grid_point object with the given coordinates, function value, and step. Promotes the eltype and type of x and fx resp. Also ensures step is Int.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.grid_point-Tuple{Function, Any, Any}","page":"Home","title":"GridMethod.grid_point","text":"grid_point(fun::Function, x, step)\n\nCreates a new grid_point object with the given function, coordinates, and step, where the function value is computed by calling fun(x...).\n\n\n\n\n\n","category":"method"},{"location":"#Base.eltype-Union{Tuple{GridMethod.grid_point{T}}, Tuple{T}} where T","page":"Home","title":"Base.eltype","text":"eltype(::grid_point{T}) where {T}\n\nReturns the type of the elements in the x field of a grid_point object.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.D","page":"Home","title":"GridMethod.D","text":"D(Jx, x, n = length(x))\n\nReturns the matrix Jx multiplied by the difference between the identity matrix and the outer product of x and its conjugate transpose.\n\nKeyword arguments:\n\nn: The size of the identity matrix.\n\n\n\n\n\n","category":"function"},{"location":"#GridMethod.Han_min-Tuple{Any, Any, Any}","page":"Home","title":"GridMethod.Han_min","text":"Han_min(H, L, C)\n\nReturns the minimum function value in H scaled by a factor of γ, where γ = 1 - inv(C) * L.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.Id-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Home","title":"GridMethod.Id","text":"Id(::Type{T}, n) where T\n\nReturns the identity matrix of size n and type T.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.K","page":"Home","title":"GridMethod.K","text":"K(F; compiled = true)\n\nReturns a function that calculates the condition number of a system of polynomials F.\n\nKeyword arguments:\n\ncompiled: A boolean indicating whether the system should be compiled before being passed to the condition number function.\n\n\n\n\n\n","category":"function"},{"location":"#GridMethod.K-Tuple{Any, Any}","page":"Home","title":"GridMethod.K","text":"K(Wnorm, Δm1)\n\nReturns a function that calculates the condition number of a system of polynomials given its Weyl norm and inverse degree matrix.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.Wnorm-Tuple{Any}","page":"Home","title":"GridMethod.Wnorm","text":"Wnorm(F; vars = _get_vars(F), expanded = true)\n\nReturns the Weyl norm of a system of polynomials F.\n\nKeyword arguments:\n\nvars: The variables of the system.\nexpanded: A boolean indicating whether the polynomials should be expanded before calculating the Weyl norm.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.Wnorm_poly-Tuple{Any}","page":"Home","title":"GridMethod.Wnorm_poly","text":"Wnorm_poly(poly; vars, expanded = false)\n\nReturns the Weyl norm of a polynomial poly.\n\nKeyword arguments:\n\nvars: The variables of the polynomial.\nexpanded: A boolean indicating whether the polynomial should be expanded before calculating the Weyl norm.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.Wnorm_term-Tuple{Any, Any}","page":"Home","title":"GridMethod.Wnorm_term","text":"Wnorm_term(I, C)\n\nReturns the term of the Weyl norm corresponding to the exponents I and coefficient C.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.Wnorm_term-Tuple{Any}","page":"Home","title":"GridMethod.Wnorm_term","text":"Wnorm_term(IC) = Wnorm_term(IC...)\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod._degrees","page":"Home","title":"GridMethod._degrees","text":"_degrees(F)\n\nReturns the degrees of a system of polynomials F.\n\n\n\n\n\n","category":"function"},{"location":"#GridMethod._exposcoeffs","page":"Home","title":"GridMethod._exposcoeffs","text":"_exposcoeffs(poly; vars, expanded = false)\n\nReturns a list of tuples containing the exponents and coefficients of a polynomial poly.\n\nKeyword arguments:\n\nvars: The variables of the polynomial.\nexpanded: A boolean indicating whether the polynomial should be expanded before extracting the exponents and coefficients.\n\n\n\n\n\n","category":"function"},{"location":"#GridMethod._get_polys","page":"Home","title":"GridMethod._get_polys","text":"_get_polys(F)\n\nReturns the polynomials of a system F.\n\n\n\n\n\n","category":"function"},{"location":"#GridMethod._get_vars-Tuple{Any}","page":"Home","title":"GridMethod._get_vars","text":"_get_vars(F)\n\nReturns the variables of a system of polynomials F.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod._isHan-Tuple{Any, Any, Any}","page":"Home","title":"GridMethod._isHan","text":"_isHan(fx, step, C)\n\nReturns true if C * step_to_ratio(step) < fx, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod._monomial","page":"Home","title":"GridMethod._monomial","text":"_monomial(X, I, n = length(X))\n\nReturns the monomial of variables X with exponents I.\n\nKeyword arguments:\n\nn: The number of variables.\n\n\n\n\n\n","category":"function"},{"location":"#GridMethod._norm-Tuple{Any}","page":"Home","title":"GridMethod._norm","text":"_norm(v)\n\nReturns the Euclidean norm of a vector v.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.coord_opt-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Home","title":"GridMethod.coord_opt","text":"coord_opt(::Type{T}, dim) where {T} = ntuple(_ -> (one(T), -one(T)), dim)\n\nReturns an iterator which generates all possible dim-dimensional vectors that have all components either one or -one. The eltype of the vector is T, which defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.cube_nthinitgrid-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T","page":"Home","title":"GridMethod.cube_nthinitgrid","text":"cube_nthinitgrid(T=Float64, fun, dim, n; ratio = 0.5, root = tree_root(T, dim),\n                 coord_opt = coord_opt(T, dim))\n\nReturns a list of grid_point objects that form an initial grid with 2^n points in each dimension.\n\nArguments:\n\nT (optional): Numeric type to represent the coordinates of the points.\nfun: The function to be evaluated at each point in the grid.\ndim: The dimension of the grid.\nn: The number of times the grid should be recursively divided.\n\nKeyword arguments:\n\nratio: The ratio between the length of a branch and of the previous.\nroot: The root of the grid (a point in dim-dimensional space).\ncoord_opt: The possible directions in which the next points can be generated.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.cube_pushsubdivided!-NTuple{4, Any}","page":"Home","title":"GridMethod.cube_pushsubdivided!","text":"cube_pushsubdivided!(G, p, step, fun; dim = length(p),\n                     coord_opt = coord_opt(eltype(p), dim))\n\nPushes the points obtained by subdividing the region around p into G.\n\nArguments:\n\nG: A list of grid_point objects, where to push the new points.\np: A point in dim-dimensional space.\nstep: The step at which the point was added to the grid.\nfun: The function to be evaluated at each point.\n\nKeyword arguments:\n\ndim: The dimension of the grid.\ncoord_opt: The possible directions in which the next points can be generated.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.fpoint-Tuple{GridMethod.grid_point}","page":"Home","title":"GridMethod.fpoint","text":"fpoint(g::grid_point)\n\nReturns the function value of the grid_point object g.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.point-Tuple{GridMethod.grid_point}","page":"Home","title":"GridMethod.point","text":"point(g::grid_point)\n\nReturns the coordinates of the grid_point object g.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.radius-Tuple{GridMethod.grid_point}","page":"Home","title":"GridMethod.radius","text":"radius(g::grid_point)\n\nReturns the radius of the grid_point object g, which is computed as 1/2^i, where i is the step at which the point was added to the grid.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.rand_poly-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T","page":"Home","title":"GridMethod.rand_poly","text":"rand_poly(::Type{T}=Float64, X, d; coeffs = I -> randn(T), n = length(X))\n\nReturns a random polynomial with coefficients of type T in variables X with degree d.\n\nKeyword arguments:\n\ncoeffs: A function that takes a tuple of exponents and returns a coefficient.\nn: The number of variables.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.refine_grid!-NTuple{5, Any}","page":"Home","title":"GridMethod.refine_grid!","text":"refine_grid!(G, fun, C, m, dim; isfine = _isHan,\n             pushsubdivide! = cube_pushsubdivided!)\n\nModifies the input list G in place to form a refined grid satisfying the Han condition.\n\nArguments:\n\nG: A list of grid_point objects.\nfun: The function to be evaluated at each point in the grid.\nC: A parameter used in the Han condition.\nm: A parameter used to determine when to stop refining the grid.\ndim: The dimension of the grid.\n\nKeyword arguments:\n\nisfine: A function that determines whether a point satisfies the Han condition.\npushsubdivide!: A function that pushes the points obtained by subdividing a region into a list of points.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.refine_grid-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any, Any}} where T","page":"Home","title":"GridMethod.refine_grid","text":"refine_grid(T=Float64, fun, C, m, dim; step₀ = Int(ceil(log2(C))),\n            G = cube_nthinitgrid(T, fun, dim, step₀), isfine = _isHan,\n            pushsubdivided! = cube_pushsubdivided!)\n\nReturns a list of grid_point objects that form a refined grid satisfying the Han condition.\n\nArguments:\n\nT (optional): Numeric type to represent the coordinates of the points.\nfun: The function to be evaluated at each point in the grid.\nC: A parameter used in the Han condition.\nm: A parameter used to determine when to stop refining the grid.\ndim: The dimension of the grid.\n\nKeyword arguments:\n\nstep₀: The initial step of the grid.\nG: The initial grid.\nisfine: A function that determines whether a point satisfies the Han condition.\npushsubdivide!: A function that pushes the points obtained by subdividing a region into a list of points.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.step_to_ratio-Tuple{Any}","page":"Home","title":"GridMethod.step_to_ratio","text":"step_to_ratio(step) = inv(exp2(step))\n\nConverts the subdivided index step of a grid_point into the ratio of such point.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.tree_nextleaves-Tuple{Any, Any}","page":"Home","title":"GridMethod.tree_nextleaves","text":"tree_nextleaves(p, ratio; dim = length(p), coord_opt = coord_opt(eltype(p), dim))\n\nReturns an iterator which generates the next leaves of the tree starting from p with a length ratio of r.\n\nKeyword arguments:\n\ndim: The dimension of the tree.\ncoord_opt: The possible directions in which the next leaves can be generated.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.tree_nthleaves-Tuple{Any, Any}","page":"Home","title":"GridMethod.tree_nthleaves","text":"tree_nthleaves(dim, n; ratio = 0.5, root = tree_root(dim),\n               coord_opt = coord_opt(dim))\n\nComputes the nth leaves of a 2^dim-branched tree in a dim-dimensional space, where dim is the dimension of the tree (i.e. 2 for a 2D tree, 3 for a 3D tree), and n is the number of times the tree should be recursively branched.\n\nKeyword arguments:\n\nratio: The ratio between the length of a branch and of the previous.\nroot: The root of the tree (a point in dim-dimensional space).\ncoord_opt: The possible directions in which the next leaves can be generated.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.tree_root-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Home","title":"GridMethod.tree_root","text":"tree_root(::Type{T}, dim) where {T} = [zeros(T, dim)]\n\nReturns an array containing a single zero-vector of length dim and type T, which defaults to Float64. It is meant to be used as the root node of a tree fractal.\n\n\n\n\n\n","category":"method"},{"location":"#GridMethod.Δm1-Tuple{Any}","page":"Home","title":"GridMethod.Δm1","text":"Δm1(F)\n\nReturns the inverse of the degree matrix of a system of polynomials F.\n\n\n\n\n\n","category":"method"}]
}
